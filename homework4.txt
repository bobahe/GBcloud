///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SERVER SIDE

// AuthService.java
package ru.bobahe.gbcloud.server.auth;

import java.sql.SQLException;

public interface AuthService {
    String getFolderByUsernameAndPassword(String username, String password);
    void insertNewUser(String username, String password, String folder) throws SQLException;
}

// SQLAuthService.java
package ru.bobahe.gbcloud.server.auth;

import ru.bobahe.gbcloud.server.db.SQLHandler;

import java.sql.SQLException;

public class SQLAuthService implements AuthService {
    @Override
    public String getFolderByUsernameAndPassword(String username, String password) {
        return SQLHandler.getFolderByUsernameAndPassword(username, password);
    }

    @Override
    public void insertNewUser(String username, String password, String folder) throws SQLException {
        SQLHandler.insertNewUser(username, password, folder);
    }
}

// SQLHandler.java
package ru.bobahe.gbcloud.server.db;

import ru.bobahe.gbcloud.server.properties.ApplicationProperties;

import java.sql.*;

public class SQLHandler {
    private static Connection connection;
    private static PreparedStatement psGetFolderByLoginAndPassword;
    private static PreparedStatement psInsertNewUser;

    public static boolean connect() {
        try {
            Class.forName("org.sqlite.JDBC");
            connection = DriverManager.getConnection(ApplicationProperties.getInstance().getProperty("db.name"));
            psGetFolderByLoginAndPassword = connection.prepareStatement("SELECT folder FROM users WHERE username = ? AND password = ?;");
            psInsertNewUser = connection.prepareStatement("INSERT INTO users (username, password, folder) VALUES (?, ?, ?)");
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    public static String getFolderByUsernameAndPassword(String username, String password) {
        String folder = null;

        try {
            psGetFolderByLoginAndPassword.setString(1, username);
            psGetFolderByLoginAndPassword.setString(2, password);
            ResultSet rs = psGetFolderByLoginAndPassword.executeQuery();
            if (rs.next()) {
                folder = rs.getString(1);
            }
            rs.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }

        return folder;
    }

    public static void disconnect() {
        try {
            psGetFolderByLoginAndPassword.close();
            psInsertNewUser.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            connection.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void insertNewUser(String username, String password, String folder) throws SQLException {
        psInsertNewUser.setString(1, username);
        psInsertNewUser.setString(2, password);
        psInsertNewUser.setString(3, folder);

        psInsertNewUser.executeUpdate();
    }
}

// FileChunkHandler.java
package ru.bobahe.gbcloud.server.net.handlers;

import io.netty.channel.Channel;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import lombok.extern.java.Log;
import ru.bobahe.gbcloud.common.FileChunk;
import ru.bobahe.gbcloud.common.fs.FileWorker;
import ru.bobahe.gbcloud.server.AuthenticatedClients;
import ru.bobahe.gbcloud.server.CommandRunner;
import ru.bobahe.gbcloud.server.properties.ApplicationProperties;

import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.concurrent.ConcurrentMap;

@Log
public class FileChunkHandler extends ChannelInboundHandlerAdapter {
    private ConcurrentMap<String, Channel> clients = AuthenticatedClients.getInstance().clients;
    private static final FileWorker fileWorker = new FileWorker();

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        if (msg instanceof FileChunk) {
            FileChunk fileChunk = (FileChunk) msg;

            Path preparedPath = Paths.get(fileChunk.getFilePath()).getFileName();

            if (fileChunk.getDestinationFilePath() != null) {
                preparedPath = Paths.get(fileChunk.getDestinationFilePath()
                        + fileChunk.getFilePath().substring(fileChunk.getFilePath().lastIndexOf(File.separator)));
            }

            if (fileChunk.getLength() != -1) {
                fileWorker.writeFileChunk(
                        Paths.get(buildLocalPath(ctx) + preparedPath.toString()),
                        fileChunk.getData(),
                        fileChunk.getOffset(),
                        fileChunk.getLength()
                );
            } else {
                CommandRunner.getInstance().sendList(CommandRunner.getInstance().getLastRequestedPathForListing(), ctx);
            }
        } else {
            System.out.println("От тебя пришла какая-то туфта.");
        }
    }

    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) {
        ctx.flush();
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        cause.printStackTrace();
        ctx.close();
    }

    private String buildLocalPath(ChannelHandlerContext ctx) {
        StringBuilder localPath = new StringBuilder();

        localPath
                .append(ApplicationProperties.getInstance().getProperty("root.directory"))
                .append(File.separator)
                .append(findUserFolderByChannel(ctx))
                .append(File.separator);

        return localPath.toString();
    }

    private String findUserFolderByChannel(ChannelHandlerContext ctx) {
        for (String key : clients.keySet()) {
            if (clients.get(key) == ctx.channel()) {
                return key;
            }
        }

        return null;
    }
}

// MessageHandler.java
package ru.bobahe.gbcloud.server.net.handlers;

import io.netty.channel.Channel;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import lombok.extern.java.Log;
import ru.bobahe.gbcloud.common.Command;
import ru.bobahe.gbcloud.server.AuthenticatedClients;
import ru.bobahe.gbcloud.server.CommandRunner;

@Log
public class MessageHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        log.info("New client connected [" + ctx.channel().remoteAddress() + "]");
    }

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        if (msg instanceof Command) {
            CommandRunner.getInstance().invoke((Command) msg, ctx);
        } else {
            if (isAuthenticatedClient(ctx.channel())) {
                ctx.fireChannelRead(msg);
            }
        }
    }

    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) {
        ctx.flush();
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        cause.printStackTrace();
        ctx.close();
    }

    private boolean isAuthenticatedClient(Channel channel) {
        return AuthenticatedClients.getInstance().clients.containsValue(channel);
    }
}

// ServerChannelInitializer.java
package ru.bobahe.gbcloud.server.net.handlers;

import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.socket.SocketChannel;
import io.netty.handler.codec.serialization.ClassResolvers;
import io.netty.handler.codec.serialization.ObjectDecoder;
import io.netty.handler.codec.serialization.ObjectEncoder;
import io.netty.handler.ssl.SslContext;
import io.netty.handler.ssl.SslContextBuilder;
import io.netty.handler.ssl.util.SelfSignedCertificate;
import ru.bobahe.gbcloud.server.properties.ApplicationProperties;

import javax.net.ssl.SSLException;
import java.security.cert.CertificateException;

public class ServerChannelInitializer extends ChannelInitializer<SocketChannel> {
    private SslContext sslContext;

    public ServerChannelInitializer() {
        boolean ssl = Boolean.parseBoolean(ApplicationProperties.getInstance().getProperty("ssl"));

        if (ssl) {
            try {
                SelfSignedCertificate certificate = new SelfSignedCertificate();
                sslContext = SslContextBuilder.forServer(
                        certificate.certificate(),
                        certificate.privateKey()
                ).build();
            } catch (CertificateException | SSLException e) {
                e.printStackTrace();
            }
        } else {
            sslContext = null;
        }
    }

    @Override
    protected void initChannel(SocketChannel socketChannel) throws Exception {
        ChannelPipeline pipeline = socketChannel.pipeline();

        if (sslContext != null) {
            pipeline.addLast(sslContext.newHandler(socketChannel.alloc()));
        }

        pipeline.addLast(
                new ObjectEncoder(),
                new ObjectDecoder(ClassResolvers.cacheDisabled(null)),
                new MessageHandler(),
                new FileChunkHandler()
        );
    }
}

// ApplicationProperties.java
package ru.bobahe.gbcloud.server.properties;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.Properties;

public class ApplicationProperties {
    private static ApplicationProperties ourInstance = new ApplicationProperties();
    private Properties properties;

    public static ApplicationProperties getInstance() {
        return ourInstance;
    }

    private ApplicationProperties() {
        properties = new Properties();
        try (FileInputStream propFileStream = new FileInputStream("server.properties")) {
            properties.load(propFileStream);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public String getProperty(String key) {
        return properties.getProperty(key);
    }
}

// AuthenticatedClients.java
package ru.bobahe.gbcloud.server;

import io.netty.channel.Channel;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class AuthenticatedClients {
    private static AuthenticatedClients ourInstance = new AuthenticatedClients();
    public ConcurrentMap<String, Channel> clients = new ConcurrentHashMap<>();

    public static AuthenticatedClients getInstance() {
        return ourInstance;
    }

    private AuthenticatedClients() {
    }
}

// CommandRunner.java
package ru.bobahe.gbcloud.server;

import io.netty.channel.Channel;
import io.netty.channel.ChannelHandlerContext;
import lombok.Getter;
import lombok.extern.java.Log;
import ru.bobahe.gbcloud.common.Command;
import ru.bobahe.gbcloud.common.FileChunk;
import ru.bobahe.gbcloud.common.Invokable;
import ru.bobahe.gbcloud.common.fs.FileWorker;
import ru.bobahe.gbcloud.server.auth.AuthService;
import ru.bobahe.gbcloud.server.auth.SQLAuthService;
import ru.bobahe.gbcloud.server.properties.ApplicationProperties;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.util.Map;
import java.util.UUID;

@Log
public class CommandRunner implements Invokable {
    private static CommandRunner ourInstance = new CommandRunner();

    private Command responseCommand;
    private static final AuthService authService = new SQLAuthService();
    private static final FileChunk fileChunk = new FileChunk();
    private static FileWorker fileWorker = new FileWorker();

    @Getter
    private String lastRequestedPathForListing;

    public static CommandRunner getInstance() {
        return ourInstance;
    }

    private CommandRunner() {

    }

    @Override
    public void invoke(Command command, ChannelHandlerContext ctx) {
        if (!isAuthenticatedClient(ctx.channel()) &&
                command.getAction() != Command.Action.AUTH &&
                command.getAction() != Command.Action.REGISTER) {
            responseCommand = Command.builder().action(Command.Action.ERROR).description("Вы не авторизовались.").build();
            ctx.write(responseCommand);
            return;
        }

        log.info("Client has sent command " + command.getAction());

        switch (command.getAction()) {
            case AUTH:
                authenticate(command.getUsername(), command.getPassword(), ctx);
                break;
            case DOWNLOAD:
                sendFile(command, ctx);
                break;
            case LIST:
                sendList(command.getPath(), ctx);
                break;
            case DELETE:
                delete(command.getPath(), ctx);
                break;
            case CREATE:
                createDirectory(command, ctx);
                break;
            case REGISTER:
                registerClient(command.getUsername(), command.getPassword(), ctx);
                break;
            case UPLOAD:
                sendUploadEcho(command, ctx);
                break;
            default:
                sendMessage(Command.Action.ERROR, "Я еще не умею обрабатывать команды " + command.getAction(), ctx);
                break;
        }
    }

    private void createDirectory(Command command, ChannelHandlerContext ctx) {
        try {
            fileWorker.createDirectory(Paths.get(
                    ApplicationProperties.getInstance().getProperty("root.directory") +
                            File.separator +
                            findUserFolderByChannel(ctx) +
                            command.getPath()
            ));
            sendList(lastRequestedPathForListing, ctx);
        } catch (IOException e) {
            sendMessage(Command.Action.ERROR, "Не удалось создать папку.", ctx);
        }
    }

    private void sendUploadEcho(Command command, ChannelHandlerContext ctx) {
        responseCommand = command;
        ctx.writeAndFlush(responseCommand);
    }

    private void registerClient(String username, String password, ChannelHandlerContext ctx) {
        try {
            String hashedPassword = new String(MessageDigest.getInstance("MD5").digest());
            String uuidFolderName = UUID.randomUUID().toString();
            authService.insertNewUser(username, hashedPassword, uuidFolderName);

            sendMessage(Command.Action.SUCCESS, "Вы успешно зарегистрированы.", ctx);

            fileWorker.createDirectory(
                    Paths.get(
                            ApplicationProperties.getInstance().getProperty("root.directory") +
                                    File.separator +
                                    uuidFolderName)
            );
        } catch (Exception e) {
            sendMessage(Command.Action.ERROR, e.getMessage(), ctx);
        }
    }

    private void delete(String path, ChannelHandlerContext ctx) {
        try {
            fileWorker.delete(Paths.get(
                    ApplicationProperties.getInstance().getProperty("root.directory") +
                            File.separator +
                            findUserFolderByChannel(ctx) +
                            File.separator +
                            path
            ));

            if (!fileWorker.isDeleteFalse()) {
                return;
            }

            sendMessage(Command.Action.ERROR, "Возникла ошибка при удалении файла/ов.", ctx);
        } catch (IOException e) {
            sendMessage(Command.Action.ERROR, e.getClass().getSimpleName() + ": " + e.getMessage(), ctx);
        } finally {
            sendList(lastRequestedPathForListing, ctx);
        }
    }

    public void sendList(String path, ChannelHandlerContext ctx) {
        lastRequestedPathForListing = path;

        try {
            Map<String, Boolean> list = fileWorker.getFileList(
                    ApplicationProperties.getInstance().getProperty("root.directory") +
                            File.separator +
                            findUserFolderByChannel(ctx) +
                            File.separator +
                            path
            );

            responseCommand = Command.builder()
                    .action(Command.Action.LIST)
                    .path(path)
                    .childFiles(list)
                    .build();
            ctx.writeAndFlush(responseCommand);
        } catch (IOException e) {
            sendMessage(Command.Action.ERROR, e.getMessage(), ctx);
        }
    }

    private void sendFile(Command command, ChannelHandlerContext ctx) {
        String pathFromCopy = ApplicationProperties.getInstance().getProperty("root.directory") +
                File.separator +
                findUserFolderByChannel(ctx) +
                command.getPath();
        String fileName = command.getPath().substring(command.getPath().lastIndexOf(File.separator));

        try {
            Files.walk(Paths.get(pathFromCopy)).forEach(p -> {
                if (!Files.isDirectory(p)) {
                    String dstPath = command.getDestinationPath() +
                            p.toString().substring(p.toString().indexOf(fileName), p.toString().lastIndexOf(File.separator));

                    fileChunk.setFilePath(p.toString());
                    fileChunk.setDestinationFilePath(dstPath);

                    try {
                        while (fileChunk.getNextChunk()) {
                            ctx.writeAndFlush(fileChunk);
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            });
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void sendMessage(Command.Action action, String s, ChannelHandlerContext ctx) {
        responseCommand = Command.builder().action(action).description(s).build();
        ctx.writeAndFlush(responseCommand);
    }

    private void authenticate(String username, String password, ChannelHandlerContext ctx) {
        String folder = null;

        try {
            folder = authService.getFolderByUsernameAndPassword(
                    username,
                    new String(MessageDigest.getInstance("MD5").digest())
            );
        } catch (Exception e) {
            sendMessage(Command.Action.ERROR, e.getMessage(), ctx);
        }

        if (folder == null) {
            sendMessage(Command.Action.ERROR, "Неверные логин и/или пароль.", ctx);
            return;
        }

        if (!new FileWorker().checkFolders(Paths.get(
                ApplicationProperties.getInstance().getProperty("root.directory") + File.separator + folder))) {
            sendMessage(Command.Action.ERROR, "На сервере отсутствует Ваша папка. Обратитесь к системному администратору.", ctx);
            ctx.close();
            return;
        }

        AuthenticatedClients.getInstance().clients.put(folder, ctx.channel());

//        sendMessage(Command.Action.SUCCESS, "Вы успешно авторизованы.", ctx);
        sendMessage(Command.Action.AUTH, "OK", ctx);

        sendList(".", ctx);
    }

    private boolean isAuthenticatedClient(Channel channel) {
        return AuthenticatedClients.getInstance().clients.containsValue(channel);
    }

    private String findUserFolderByChannel(ChannelHandlerContext ctx) {
        for (String key : AuthenticatedClients.getInstance().clients.keySet()) {
            if (AuthenticatedClients.getInstance().clients.get(key) == ctx.channel()) {
                return key;
            }
        }

        return null;
    }
}

// Server.java
package ru.bobahe.gbcloud.server;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.handler.logging.LoggingHandler;
import ru.bobahe.gbcloud.common.fs.FileWorker;
import ru.bobahe.gbcloud.server.db.SQLHandler;
import ru.bobahe.gbcloud.server.net.handlers.ServerChannelInitializer;
import ru.bobahe.gbcloud.server.properties.ApplicationProperties;

import java.nio.file.Paths;

class Server {
    private int port = Integer.parseInt(ApplicationProperties.getInstance().getProperty("port"));

    Server() {
        if (!checkRootFolder()) {
            throw new IllegalStateException("Отстутствует папка-хранилище!");
        }

        if (!SQLHandler.connect()) {
            throw new RuntimeException("Не удалось подключиться к БД.");
        }

        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ServerChannelInitializer());

            b.bind(port).sync().channel().closeFuture().sync();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }

    private boolean checkRootFolder() {
        return new FileWorker().checkFolders(
                Paths.get(ApplicationProperties.getInstance().getProperty("root.directory"))
        );
    }
}

// MainApp.java
package ru.bobahe.gbcloud.server;

public class MainApp {
    public static void main(String[] args) {
        new Server();
    }
}

// END OF SERVER SIDE
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CLIENT SIDE

// MainController.java
package ru.bobahe.gbcloud.client.controller;

import javafx.application.Platform;
import javafx.beans.Observable;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.StringProperty;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.GridPane;
import javafx.scene.paint.Paint;
import javafx.scene.shape.Circle;
import javafx.stage.Modality;
import javafx.stage.Stage;
import ru.bobahe.gbcloud.client.net.Client;
import ru.bobahe.gbcloud.client.viewmodel.Filec;
import ru.bobahe.gbcloud.client.viewmodel.GlobalViewModel;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.ResourceBundle;

public class MainController implements Initializable {
    private static final Client client = new Client();
    private globalViewModel model = globalViewModel.getInstance().setClient(client);
    private ObservableList<Filec> clientFilesList = model.getClientFilesList();
    private ObservableList<Filec> serverFilesList = model.getServerFilesList();
    private StringProperty serverPath = model.getServerPath();
    private StringProperty clientPath = model.getClientPath();

    @FXML
    private AnchorPane anchorPane;

    @FXML
    private GridPane clientGridPane;

    @FXML
    private TableView<Filec> clientFilesTable, serverFilesTable;

    @FXML
    private Label lblClientPath, lblServerPath;

    @FXML
    private Circle connected;

    @FXML
    private ContextMenu serverFilesMenu;

    @Override
    public void initialize(URL location, ResourceBundle resources) {
        clientPath.setValue(File.separator);
        lblClientPath.textProperty().bind(clientPath);
        serverPath.setValue(File.separator);
        lblServerPath.textProperty().bind(serverPath);

        prepareTableViews();

        model.getClientFileList();

        model.getMessageFromServer().addListener(this::messageFromServer);
        model.getIsAuthenticated().addListener(this::getAuthCommand);
    }

    private void getAuthCommand(Observable observable) {
        boolean isAuthOk = ((BooleanProperty) observable).get();
        serverFilesMenu.getItems().forEach(mi -> mi.setDisable(!isAuthOk));
        if (isAuthOk) {
            connected.setFill(Paint.valueOf("green"));
        }
    }

    private void messageFromServer(Observable observable) {
        Platform.runLater(() -> {
            Alert.AlertType type = Alert.AlertType.ERROR;
            String headerText = "Ошибка";

            if (model.getMessageFromServerType().get() == 0) {
                type = Alert.AlertType.INFORMATION;
                headerText = "Успех";
            }

            Alert alert = new Alert(type, ((StringProperty) observable).get(), ButtonType.OK);
            alert.setTitle("Собщение от сервера");
            alert.setHeaderText(headerText);
            alert.showAndWait();
        });
    }

    @SuppressWarnings("unchecked")
    private void prepareTableViews() {
        clientFilesTable.getColumns().addAll(
                getNewColumn("Имя", "name"),
                getNewColumn("Тип", "isFolder")
        );
        clientFilesTable.setItems(clientFilesList);

        serverFilesTable.getColumns().addAll(
                getNewColumn("Имя", "name"),
                getNewColumn("Тип", "isFolder")
        );
        serverFilesTable.setItems(serverFilesList);

        setTableViewsColumnWidth();
    }

    private void setTableViewsColumnWidth() {
        Platform.runLater(() -> {
            clientFilesTable.getColumns().get(0).setPrefWidth(clientFilesTable.getWidth() * 85 / 100);
            clientFilesTable.getColumns().get(1).setPrefWidth(clientFilesTable.getWidth() * 14 / 100);
            serverFilesTable.getColumns().get(0).setPrefWidth(clientFilesTable.getWidth() * 85 / 100);
            serverFilesTable.getColumns().get(1).setPrefWidth(clientFilesTable.getWidth() * 14 / 100);
        });
    }

    private TableColumn<Filec, String> getNewColumn(String name, String propertyName) {
        TableColumn<Filec, String> newColumn = new TableColumn<>(name);
        newColumn.setCellValueFactory(new PropertyValueFactory<>(propertyName));
        return newColumn;
    }

    public void clientFilesTableClick(MouseEvent mouseEvent) {
        if (mouseEvent.getClickCount() > 1) {
            model.changeDir(clientFilesTable, clientPath, true);
        }
    }

    public void clientFilesTableKeyPressed(KeyEvent keyEvent) {
        switch (keyEvent.getCode()) {
            case ENTER:
                model.changeDir(clientFilesTable, clientPath, true);
                break;
            case F5:
                model.copyToServer(clientFilesTable, clientPath, serverPath);
                break;
            case F7:
                showNewDirectoryModal(true);
                break;
            case F8:
                try {
                    model.delete(true, clientFilesTable);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                break;
        }
    }

    public void menuConnectAction(ActionEvent actionEvent) {
        new Thread(() -> {
            try {
                if (client.getChannel() == null) {
                    client.connect();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }).start();
    }

    public void serverFilesTableClick(MouseEvent mouseEvent) {
        if (mouseEvent.getClickCount() > 1) {
            model.changeDir(serverFilesTable, serverPath, false);
        }
    }

    public void serverFilesTableKeyPressed(KeyEvent keyEvent) {
        switch (keyEvent.getCode()) {
            case ENTER:
                model.changeDir(serverFilesTable, serverPath, false);
                break;
            case F5:
                model.copyFromServer(serverFilesTable, clientPath, serverPath);
                break;
            case F7:
                showNewDirectoryModal(false);
                break;
            case F8:
                try {
                    model.delete(false, serverFilesTable);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                break;
        }
    }

    private void showNewDirectoryModal(boolean isClient) {
        // todo Разобраться с редактированием TableView
//        if (isClient) {
//            Filec dir = Filec.builder().name(String.valueOf(clientFilesTable.getItems().size())).isFolder("папка").build();
//            clientFilesTable.getItems().add(dir);
//            clientFilesTable.getSelectionModel().select(dir);
//            //clientFilesTable.setEditable(true);
//            clientFilesTable.layout();
//            clientFilesTable.edit(clientFilesTable.getItems().size() - 1, clientFilesTable.getColumns().get(1));
//        }
        try {
            Stage stage = new Stage();
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/NewDirectory.fxml"));
            Parent root = loader.load();
            NewDirectoryController controller = loader.getController();
            controller.setPath(isClient ? clientPath.get() : serverPath.get());
            controller.setClient(isClient);

            stage.setTitle("Новая папка");
            stage.setScene(new Scene(root, 270, 100));
            stage.initModality(Modality.APPLICATION_MODAL);
            stage.showAndWait();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private boolean isClientContextMenu(ActionEvent actionEvent) {
        return ((MenuItem) actionEvent.getSource()).getParentPopup().getId().startsWith("client");
    }

    public void newDirectoryMenuItemClicked(ActionEvent actionEvent) {
        showNewDirectoryModal(isClientContextMenu(actionEvent));
    }

    public void deleteMenuItemClicked(ActionEvent actionEvent) {
        try {
            TableView<Filec> tw = serverFilesTable;
            if (isClientContextMenu(actionEvent)) {
                tw = clientFilesTable;
            }
            model.delete(isClientContextMenu(actionEvent), tw);
        } catch (Exception e) {
            Alert alert = new Alert(Alert.AlertType.ERROR, e.getMessage(), ButtonType.OK);
            alert.setTitle("Удаление");
            alert.setHeaderText("Ошибка");
            alert.showAndWait();
        }
    }

    public void copyMenuItemClicked(ActionEvent actionEvent) {
        if (isClientContextMenu(actionEvent)) {
            model.copyToServer(clientFilesTable, clientPath, serverPath);
        } else {
            model.copyFromServer(serverFilesTable, clientPath, serverPath);
        }
    }
}

// NewDirectoryController.java
package ru.bobahe.gbcloud.client.controller;

import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.scene.control.TextField;
import javafx.stage.Stage;
import lombok.Setter;
import ru.bobahe.gbcloud.client.viewmodel.GlobalViewModel;

public class NewDirectoryController {
    globalViewModel model = globalViewModel.getInstance();

    @FXML
    TextField directoryName;

    @Setter
    private String path;

    @Setter
    private boolean isClient;

    public void createDirectory(ActionEvent actionEvent) {
        try {
            model.createDirectory(isClient, path + directoryName.getText());
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            ((Stage) directoryName.getScene().getWindow()).close();
        }
    }
}

// Client.java
package ru.bobahe.gbcloud.client.net;

import io.netty.bootstrap.Bootstrap;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.serialization.ClassResolvers;
import io.netty.handler.codec.serialization.ObjectDecoder;
import io.netty.handler.codec.serialization.ObjectEncoder;
import io.netty.handler.ssl.SslContext;
import io.netty.handler.ssl.SslContextBuilder;
import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
import ru.bobahe.gbcloud.client.properties.ApplicationProperties;

public class Client {
    private static boolean ssl = Boolean.parseBoolean(ApplicationProperties.getInstance().getProperty("ssl"));

    private Bootstrap bootstrap;
    private Channel channel;

    public void connect() throws Exception {
        final SslContext sslCtx;
        if (ssl) {
            sslCtx = SslContextBuilder.forClient()
                    .trustManager(InsecureTrustManagerFactory.INSTANCE).build();
        } else {
            sslCtx = null;
        }

        EventLoopGroup group = new NioEventLoopGroup();
        try {
            bootstrap = new Bootstrap();
            bootstrap.group(group)
                    .channel(NioSocketChannel.class)
                    .handler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        public void initChannel(SocketChannel ch) throws Exception {
                            ChannelPipeline p = ch.pipeline();

                            if (sslCtx != null) {
                                p.addLast(sslCtx.newHandler(ch.alloc(), "127.0.0.1", 8192));
                            }

                            p.addLast(
                                    new ObjectEncoder(),
                                    new ObjectDecoder(ClassResolvers.cacheDisabled(null)),
                                    new MessageHandler(),
                                    new FileChunkHandler()
                            );
                        }
                    });

            channel = bootstrap.connect("127.0.0.1", 8192).sync().channel();
            channel.closeFuture().sync();
        } finally {
            group.shutdownGracefully();
        }
    }

    public Channel getChannel() {
        return channel;
    }
}

// FileChunkHandler.java
package ru.bobahe.gbcloud.client.net;

import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import ru.bobahe.gbcloud.client.properties.ApplicationProperties;
import ru.bobahe.gbcloud.client.viewmodel.GlobalViewModel;
import ru.bobahe.gbcloud.common.FileChunk;
import ru.bobahe.gbcloud.common.fs.FileWorker;

import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;

public class FileChunkHandler extends ChannelInboundHandlerAdapter {
    private static final FileWorker fileWorker = new FileWorker();

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        if (msg instanceof FileChunk) {
            FileChunk fileChunk = (FileChunk) msg;

            Path preparedPath = Paths.get(fileChunk.getFilePath()).getFileName();

            if (fileChunk.getDestinationFilePath() != null) {
                preparedPath = Paths.get(fileChunk.getDestinationFilePath()
                        + fileChunk.getFilePath().substring(fileChunk.getFilePath().lastIndexOf(File.separator)));
            }

            if (fileChunk.getLength() != -1) {
                fileWorker.writeFileChunk(
                        Paths.get(buildLocalPath(ctx) + preparedPath.toString()),
                        fileChunk.getData(),
                        fileChunk.getOffset(),
                        fileChunk.getLength()
                );
            } else {
                globalViewModel.getInstance().getClientFilesList().clear();
                globalViewModel.getInstance().getClientFileList();
            }
        }
    }

    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) {
        ctx.flush();
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        cause.printStackTrace();
        ctx.close();
    }

    private String buildLocalPath(ChannelHandlerContext ctx) {
        StringBuilder localPath = new StringBuilder();

        localPath
                .append(ApplicationProperties.getInstance().getProperty("root.directory"))
                .append(File.separator);

        return localPath.toString();
    }
}

// MessageHandler.java
package ru.bobahe.gbcloud.client.net;

import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import ru.bobahe.gbcloud.client.properties.ApplicationProperties;
import ru.bobahe.gbcloud.client.viewmodel.Filec;
import ru.bobahe.gbcloud.client.viewmodel.GlobalViewModel;
import ru.bobahe.gbcloud.common.Command;
import ru.bobahe.gbcloud.common.FileChunk;

import java.io.File;
import java.io.IOException;

public class MessageHandler extends ChannelInboundHandlerAdapter {
    private Command responseCommand;
    private static final FileChunk fileChunk = new FileChunk();

    private globalViewModel model = globalViewModel.getInstance();

    public MessageHandler() {

    }

    @Override
    public void channelActive(ChannelHandlerContext ctx) throws IOException {
//        responseCommand = Command.builder()
//                .action(Command.Action.REGISTER)
//                .username("user")
//                .password("password")
//                .build();
//        ctx.writeAndFlush(responseCommand);

        responseCommand = Command.builder()
                .action(Command.Action.AUTH)
                .username("user")
                .password("password")
                .build();
        ctx.writeAndFlush(responseCommand);
    }

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        if (msg instanceof Command) {
            Command receivedCommand = (Command) msg;

            switch (receivedCommand.getAction()) {
                case ERROR:
                    model.getMessageFromServerType().set(1);
                    model.getMessageFromServer().set(receivedCommand.getDescription());
                    break;
                case SUCCESS:
                    model.getMessageFromServerType().set(0);
                    model.getMessageFromServer().set(receivedCommand.getDescription());
                    break;
                case AUTH:
                    model.getIsAuthenticated().set(receivedCommand.getDescription().equals("OK"));
                    break;
                case LIST:
                    model.getServerFilesList().clear();

                    if (!model.getServerPath().get().equals(File.separator)) {
                        model.getServerFilesList().add(
                                Filec.builder().name("..").isFolder("папка").build()
                        );
                    }
                    receivedCommand.getChildFiles().forEach((n, f) ->
                            model.getServerFilesList().add(
                                    Filec.builder().name(n).isFolder(f ? "папка" : "").build()
                            )
                    );
                    break;
                case UPLOAD:
                    fileChunk.setFilePath(
                            ApplicationProperties.getInstance().getProperty("root.directory") +
                                    receivedCommand.getPath()
                    );
                    fileChunk.setDestinationFilePath(receivedCommand.getDestinationPath());

                    try {
                        while (fileChunk.getNextChunk()) {
                            ctx.writeAndFlush(fileChunk);
                        }
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    break;
            }
        } else {
            ctx.fireChannelRead(msg);
        }
    }

    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) {
        ctx.flush();
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        cause.printStackTrace();
        ctx.close();
    }
}

// ApplicationProperties.java
package ru.bobahe.gbcloud.client.properties;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.Properties;

public class ApplicationProperties {
    private static ApplicationProperties ourInstance = new ApplicationProperties();
    private Properties properties;

    public static ApplicationProperties getInstance() {
        return ourInstance;
    }

    private ApplicationProperties() {
        properties = new Properties();
        try (FileInputStream propFileStream = new FileInputStream("client.properties")) {
            properties.load(propFileStream);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public String getProperty(String key) {
        return properties.getProperty(key);
    }
}

// Filec.java
package ru.bobahe.gbcloud.client.viewmodel;

import lombok.Builder;
import lombok.Getter;
import lombok.ToString;

@Getter
@Builder
@ToString
public class Filec {
    private String name;
    private String isFolder;
}

// GlobalViewModel.java
package ru.bobahe.gbcloud.client.viewmodel;

import javafx.beans.property.*;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.scene.control.TableView;
import lombok.Getter;
import ru.bobahe.gbcloud.client.net.Client;
import ru.bobahe.gbcloud.client.properties.ApplicationProperties;
import ru.bobahe.gbcloud.common.Command;
import ru.bobahe.gbcloud.common.fs.FileWorker;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Map;

public class GlobalViewModel {
    // region Singleton
    private static GlobalViewModel ourInstance = new GlobalViewModel();

    private GlobalViewModel() {}

    public static GlobalViewModel getInstance() {
        return ourInstance;
    }
    // endregion

    private Client client;
    private Command responseCommand;
    private FileWorker fileWorker = new FileWorker();

    @Getter
    private ObservableList<Filec> clientFilesList = FXCollections.observableArrayList();

    @Getter
    private ObservableList<Filec> serverFilesList = FXCollections.observableArrayList();

    @Getter
    private StringProperty serverPath = new SimpleStringProperty();

    @Getter
    private StringProperty clientPath = new SimpleStringProperty();

    @Getter
    private StringProperty messageFromServer = new SimpleStringProperty();

    @Getter
    private IntegerProperty messageFromServerType = new SimpleIntegerProperty();

    @Getter
    private BooleanProperty isAuthenticated = new SimpleBooleanProperty(false);

    public GlobalViewModel setClient(Client client) {
        ourInstance.client = client;
        return ourInstance;
    }

    public void getClientFileList() {
        try {
            if (!clientPath.get().equals(File.separator)) {
                clientFilesList.add(Filec.builder().name("..").isFolder("папка").build());
            }
            Map<String, Boolean> fileList = new FileWorker().getFileList(
                    ApplicationProperties.getInstance().getProperty("root.directory") +
                            clientPath.get());
            fileList.forEach((n, f) -> clientFilesList.add(Filec.builder().name(n).isFolder(f ? "папка" : "").build()));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void getServerFileList() {
        responseCommand = Command.builder()
                .action(Command.Action.LIST)
                .path(serverPath.get())
                .build();
        client.getChannel().writeAndFlush(responseCommand);
    }

    public void changeDir(TableView<Filec> tw, StringProperty path, boolean isClientPath) {
        Filec selectedItem = tw.getSelectionModel().getSelectedItem();

        if (selectedItem == null) {
            return;
        }

        if (selectedItem.getIsFolder().equals("папка")) {
            if (selectedItem.getName().equals("..")) {
                int lastIndex = path.get().length() - 2;
                path.setValue(
                        path.get().substring(
                                0,
                                path.get().substring(0, lastIndex).lastIndexOf(File.separator) + 1
                        )
                );
            } else {
                path.setValue(path.get() + selectedItem.getName() + File.separator);
            }

            if (isClientPath) {
                clientFilesList.clear();
                getClientFileList();
            } else {
                getServerFileList();
            }
        }
    }

    public void copyToServer(TableView<Filec> tw, StringProperty from, StringProperty to) {
        Filec selectedItem = tw.getSelectionModel().getSelectedItem();

        if (selectedItem == null || selectedItem.getName().equals("..")) {
            return;
        }

        if (client.getChannel() == null) {
            return;
        }

        String sourcePath = ApplicationProperties.getInstance().getProperty("root.directory") + from.get() + selectedItem.getName();

        try {
            Files.walk(Paths.get(sourcePath)).forEach(p -> {
                if (!Files.isDirectory(p)) {
                    String dstPath = to.get();

                    if (selectedItem.getIsFolder().equals("папка")) {
                        dstPath = to.get() + p.toString().substring(
                                p.toString().indexOf(selectedItem.getName()),
                                p.toString().lastIndexOf("/") + 1
                        );
                    }

                    responseCommand = Command.builder()
                            .action(Command.Action.UPLOAD)
                            .path(File.separator + p.subpath(1, p.getNameCount()).toString())
                            .destinationPath(dstPath)
                            .build();
                    client.getChannel().writeAndFlush(responseCommand);
                }
            });
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void copyFromServer(TableView<Filec> serverFilesTable, StringProperty clientPath, StringProperty serverPath) {
        Filec selectedItem = serverFilesTable.getSelectionModel().getSelectedItem();

        if (selectedItem == null || selectedItem.getName().equals("..")) {
            return;
        }

        if (client.getChannel() == null) {
            return;
        }

        responseCommand = Command.builder()
                .action(Command.Action.DOWNLOAD)
                .path(serverPath.get() + selectedItem.getName())
                .destinationPath(clientPath.get())
                .build();
        client.getChannel().writeAndFlush(responseCommand);
    }

    public void delete(boolean isClient, TableView<Filec> tw) throws Exception {
        Filec selecteItem = tw.getSelectionModel().getSelectedItem();

        if (selecteItem == null || selecteItem.getName().equals("..")) {
            return;
        }

        if (isClient) {
            Path pathToDelete = Paths.get(
                    ApplicationProperties.getInstance().getProperty("root.directory") +
                            clientPath.get() +
                            selecteItem.getName()
            );
            fileWorker.delete(pathToDelete);
            clientFilesList.clear();
            getClientFileList();
        } else {
            if (client.getChannel() == null) {
                return;
            }

            responseCommand = Command.builder()
                    .action(Command.Action.DELETE)
                    .path(serverPath.get() + selecteItem.getName())
                    .build();
            client.getChannel().writeAndFlush(responseCommand);
        }
    }

    public void createDirectory(boolean isClient, String path) throws Exception {
        if (isClient) {
            fileWorker.createDirectory(Paths.get(
                    ApplicationProperties.getInstance().getProperty("root.directory") + path));
            clientFilesList.clear();
            getClientFileList();
        } else {
            if (client.getChannel() == null) {
                return;
            }

            responseCommand = Command.builder()
                    .action(Command.Action.CREATE)
                    .path(path)
                    .build();
            client.getChannel().writeAndFlush(responseCommand);
        }
    }
}

// MainApp.java
package ru.bobahe.gbcloud.client;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.paint.Color;
import javafx.stage.Stage;
import ru.bobahe.gbcloud.client.properties.ApplicationProperties;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

//todo Сделать форму для авторизации и регистрации

public class MainApp extends Application {
    public static void main(String[] args) {
        launch(args);
        checkRootFolder();
    }

    private static void checkRootFolder() {
        try {
            Files.createDirectories(Paths.get(ApplicationProperties.getInstance().getProperty("root.directory")));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void start(Stage primaryStage) throws Exception {
        FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource("/fxml/Main.fxml"));
        Parent root = fxmlLoader.load();
        //primaryStage.initStyle(StageStyle.TRANSPARENT);
        primaryStage.setTitle("GBCloud client");
        Scene scene = new Scene(root, 1024, 768);
        scene.setFill(Color.TRANSPARENT);

        primaryStage.setScene(scene);
        primaryStage.show();
    }
}
